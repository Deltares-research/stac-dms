import { existsSync } from 'node:fs';
import { defineNuxtModule, createResolver, addTemplate, addImportsSources, addServerImports, addTypeTemplate, addPlugin, addServerPlugin } from '@nuxt/kit';
import openapiTS, { astToString } from 'openapi-typescript';
import { camelCase, kebabCase, pascalCase } from 'scule';
import { defu } from 'defu';
import { join } from 'pathe';

const moduleName = "open-fetch";
const module = defineNuxtModule({
  meta: {
    name: `nuxt-${moduleName}`,
    configKey: camelCase(moduleName),
    compatibility: {
      nuxt: "^3.0.0"
    }
  },
  async setup(options, nuxt) {
    const { resolve } = createResolver(import.meta.url);
    const schemas = [];
    const clients = defu(nuxt.options.runtimeConfig.openFetch, options.clients);
    nuxt.options.runtimeConfig.public.openFetch = Object.fromEntries(Object.entries(clients).map(([key, { schema: _, ...options2 }]) => [key, options2]));
    for (const layer of nuxt.options._layers) {
      const { srcDir, openFetch } = layer.config;
      const schemasDir = resolve(srcDir, "openapi");
      const layerClients = Object.entries(clients).filter(([key]) => openFetch?.clients?.[key]);
      for (const [name, config] of layerClients) {
        if (schemas.some((item) => item.name === name) || !config)
          continue;
        let schema = config.schema;
        if (!config.schema) {
          const jsonPath = resolve(schemasDir, `${name}/openapi.json`);
          const yamlPath = resolve(schemasDir, `${name}/openapi.yaml`);
          schema = existsSync(jsonPath) ? jsonPath : existsSync(yamlPath) ? yamlPath : void 0;
          schema = schema ? new URL(`file://${schema}`) : void 0;
        } else if (typeof config.schema === "string") {
          schema = isValidUrl(config.schema) ? config.schema : new URL(`file://${resolve(srcDir, config.schema)}`);
        }
        if (!schema)
          throw new Error(`Could not find OpenAPI schema for "${name}"`);
        schemas.push({
          name,
          fetchName: {
            composable: getClientName(name),
            lazyComposable: getClientName(name, true)
          },
          schema,
          openAPITS: options?.openAPITS
        });
      }
    }
    nuxt.options.alias = {
      ...nuxt.options.alias,
      "#open-fetch-schemas/*": join(nuxt.options.buildDir, "types", moduleName, "schemas", "*")
    };
    nuxt.options.optimization = nuxt.options.optimization || {
      keyedComposables: []
    };
    nuxt.options.optimization.keyedComposables = [
      ...nuxt.options.optimization.keyedComposables,
      ...schemas.flatMap(({ fetchName }) => [
        { name: fetchName.composable, argumentLength: 3 },
        { name: fetchName.lazyComposable, argumentLength: 3 }
      ])
    ];
    schemas.forEach(({ name, schema, openAPITS }) => {
      addTemplate({
        filename: `types/${moduleName}/schemas/${kebabCase(name)}.ts`,
        getContents: async () => {
          const ast = await openapiTS(schema, openAPITS);
          return astToString(ast);
        },
        write: true
      });
    });
    addImportsSources({
      from: resolve(nuxt.options.buildDir, `${moduleName}.ts`),
      imports: schemas.flatMap(({ fetchName }) => Object.values(fetchName))
    });
    addImportsSources({
      from: resolve(`runtime/fetch`),
      imports: [
        "createOpenFetch",
        "openFetchRequestInterceptor",
        "OpenFetchClient",
        "OpenFetchOptions"
      ]
    });
    addImportsSources({
      from: resolve(`runtime/useFetch`),
      imports: [
        "createUseOpenFetch",
        "UseOpenFetchClient"
      ]
    });
    addServerImports([{
      name: "createOpenFetch",
      from: resolve("runtime/fetch")
    }]);
    addServerImports([{
      name: "OpenFetchClient",
      from: resolve("runtime/fetch")
    }]);
    addTemplate({
      filename: `${moduleName}.ts`,
      getContents() {
        return `
import { createUseOpenFetch } from '#imports'
${schemas.map(({ name }) => `
import type { paths as ${pascalCase(name)}Paths } from '#open-fetch-schemas/${kebabCase(name)}'
`.trimStart()).join("").trimEnd()}

${schemas.length ? `export type OpenFetchClientName = ${schemas.map(({ name }) => `'${name}'`).join(" | ")}` : ""}

${schemas.map(({ name, fetchName }) => `
/**
 * Fetch data from an OpenAPI endpoint with an SSR-friendly composable.
 * See {@link https://nuxt-open-fetch.vercel.app/composables/useclient}
 * @param string The OpenAPI path to fetch
 * @param opts extends useFetch, $fetch options and useAsyncData options
 */
export const ${fetchName.composable} = createUseOpenFetch<${pascalCase(name)}Paths>('${name}')
/**
 * Fetch data from an OpenAPI endpoint with an SSR-friendly composable.
 * See {@link https://nuxt-open-fetch.vercel.app/composables/uselazyclient}
 * @param string The OpenAPI path to fetch
 * @param opts extends useFetch, $fetch options and useAsyncData options
 */
export const ${fetchName.lazyComposable} = createUseOpenFetch<${pascalCase(name)}Paths>('${name}', true)
`.trimStart()).join("\n")}`.trimStart();
      },
      write: true
    });
    addTypeTemplate({
      filename: `types/${moduleName}/nuxt.d.ts`,
      getContents: () => `
import type { OpenFetchClient } from '#imports'
${schemas.map(({ name }) => `
import type { paths as ${pascalCase(name)}Paths } from '#open-fetch-schemas/${kebabCase(name)}'
`.trimStart()).join("").trimEnd()}

declare module '#app' {
  interface NuxtApp {
    ${schemas.map(({ name }) => `$${name}: OpenFetchClient<${pascalCase(name)}Paths>`.trimStart()).join("\n    ")}
  }
}

declare module 'vue' {
  interface ComponentCustomProperties {
    ${schemas.map(({ name }) => `$${name}: OpenFetchClient<${pascalCase(name)}Paths>`.trimStart()).join("\n    ")}
  }
}

export {}
`.trimStart()
    });
    addTemplate({
      filename: `types/${moduleName}/nitro.d.ts`,
      getContents: () => `
import type { OpenFetchClient } from '#imports'
${schemas.map(({ name }) => `
import type { paths as ${pascalCase(name)}Paths } from '#open-fetch-schemas/${kebabCase(name)}'
`.trimStart()).join("").trimEnd()}

declare module 'nitropack' {
  interface NitroApp {
    ${schemas.map(({ name }) => `$${name}: OpenFetchClient<${pascalCase(name)}Paths>`.trimStart()).join("\n    ")}
  }
}

export {}
`.trimStart()
    });
    nuxt.hook("nitro:config", (nitroConfig) => {
      nitroConfig.typescript?.tsConfig?.include?.push(`./types/${moduleName}/nitro.d.ts`);
    });
    if (!options.disableNuxtPlugin)
      addPlugin(resolve("./runtime/nuxt-plugin"));
    if (!options.disableNitroPlugin) {
      nuxt.options.build.transpile.push(resolve("./runtime/nitro-plugin"));
      addServerPlugin(resolve("./runtime/nitro-plugin"));
    }
  }
});
function getClientName(name, lazy = false) {
  return `use${lazy ? "Lazy" : ""}${pascalCase(name)}`;
}
function isValidUrl(url) {
  try {
    return Boolean(new URL(url));
  } catch (e) {
    return false;
  }
}

export { module as default };
